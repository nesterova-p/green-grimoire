const { pendingDownloads } = require('../services/videoDownload');
const { rateRecipe, getRecipeRating, deleteRecipeRating } = require('../database/ratingService');
const { getRecipeById } = require('../database/recipeService');
const { query } = require('../database/connection');

const safeEditMessage = async (ctx, text, options = {}) => {
    try {
        await ctx.editMessageText(text, options);
    } catch (error) {
        if (error.message.includes('message is not modified')) {
            console.log('Message already shows expected content - skipping edit');
            return;
        } else if (error.message.includes('message to edit not found')) {
            await ctx.reply(text, options);
        } else {
            throw error;
        }
    }
};

const setupDownloadHandlers = (bot) => {
    bot.action('download_confirm', async (ctx) => {
        try {
            await ctx.answerCbQuery('üîÆ Starting download ritual!');

            const userId = ctx.from.id;
            const pending = pendingDownloads.get(userId);

            if (!pending) {
                await safeEditMessage(ctx,
                    '‚ö†Ô∏è *Download session expired!* Please send the video link again.',
                    { parse_mode: 'Markdown' }
                );
                return;
            }

            pendingDownloads.delete(userId);

            await safeEditMessage(ctx,
                `üîÆ‚ö° *Moss prepares the downloading ritual!* ‚ö°üîÆ

üßô‚Äç‚ôÄÔ∏è *Your wish is my command, dear cook!*
üìú *Beginning the sacred video capture...*

*Ancient magic is flowing...* üåø‚ö°`,
                { parse_mode: 'Markdown' }
            );

            const { downloadActualVideo } = require('../services/videoDownload');
            await downloadActualVideo(pending.url, ctx, pending.videoInfo, ctx.callbackQuery.message.message_id);

        } catch (error) {
            console.error('Download confirm error:', error);
            await ctx.reply('üêõ Error starting download! Please try again.');
        }
    });

    bot.action('download_cancel', async (ctx) => {
        try {
            await ctx.answerCbQuery('‚ùå Download cancelled');

            const userId = ctx.from.id;
            pendingDownloads.delete(userId);

            await safeEditMessage(ctx,
                `üåø‚ú® *Moss nods understandingly* ‚ú®üåø

üßô‚Äç‚ôÄÔ∏è *No worries, dear cook! The video portal remains open in the ether.*
üìú *Send another video link anytime you're ready for downloading magic!*

*Moss returns to tending the grimoire...* üçÑüìö`,
                { parse_mode: 'Markdown' }
            );

        } catch (error) {
            console.error('Download cancel error:', error);
        }
    });

    bot.action('info_only', async (ctx) => {
        try {
            await ctx.answerCbQuery('üìã Video info preserved!');

            const userId = ctx.from.id;
            const pending = pendingDownloads.get(userId);
            pendingDownloads.delete(userId);

            await safeEditMessage(ctx,
                `üìã‚ö° *Video Information Preserved* ‚ö°üìã

üé¨ **Title:** ${pending?.videoInfo?.title || 'Unknown'}
‚è±Ô∏è **Duration:** ${pending?.videoInfo?.duration ? `${Math.floor(pending.videoInfo.duration / 60)}m ${Math.floor(pending.videoInfo.duration % 60)}s` : 'Unknown'}
üì± **Platform:** ${pending?.url?.includes('tiktok') ? 'TikTok' : pending?.url?.includes('youtube') ? 'YouTube' : 'Unknown'}

üåø *Video link saved for your reference - no download performed.*
üìú *Send another video link when ready for recipe extraction!*`,
                { parse_mode: 'Markdown' }
            );

        } catch (error) {
            console.error('Info only error:', error);
        }
    });
};

const setupRecipeHandlers = (bot) => {
    bot.action(/view_recipe_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üìñ Loading recipe...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);

            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found or not accessible!');
                return;
            }

            if (recipe.video_file_id && recipe.video_chat_id) {
                try {
                    await ctx.replyWithVideo(recipe.video_file_id, {
                        caption: `üé¨ **Original Video** üé¨\nüìù **Recipe:** ${recipe.title}\nüåø *Refreshing your memory with the source video!* ‚ú®`,
                        parse_mode: 'Markdown'
                    });
                } catch (videoError) {
                    console.log('Could not resend video (might be expired):', videoError.message);
                    if (recipe.original_video_url) {
                        await ctx.reply(`üîó **Original Video:** ${recipe.original_video_url}`);
                    }
                }
            }

            let message = `üìñ **${recipe.title}** üìñ

${recipe.structured_recipe}`;

            if (recipe.user_rating) {
                const stars = '‚≠ê'.repeat(recipe.user_rating);
                message += `\n\n‚≠ê **Your Rating:** ${stars} (${recipe.user_rating}/5)`;
                if (recipe.rating_notes) {
                    message += `\nüí≠ **Notes:** "${recipe.rating_notes}"`;
                }
            }

            message += `\n\nüìÖ **Saved:** ${new Date(recipe.created_at).toLocaleDateString()}
üì± **Platform:** ${recipe.video_platform}

üåø *From your digital grimoire* ‚ú®`;

            await ctx.reply(message, { parse_mode: 'Markdown' });

        } catch (error) {
            console.error('View recipe error:', error);
            await ctx.reply('üêõ Error loading recipe!');
        }
    });

    bot.action(/delete_recipe_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üóëÔ∏è Confirm deletion...');

            await ctx.reply(
                `üóëÔ∏è **Confirm Recipe Deletion** üóëÔ∏è

‚ö†Ô∏è Are you sure you want to delete this recipe?
üìö This action cannot be undone!

üåø *Choose wisely, dear cook...* ‚ú®`,
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: '‚úÖ Yes, Delete It', callback_data: `confirm_delete_${recipeId}` },
                                { text: '‚ùå No, Keep It', callback_data: 'cancel_delete' }
                            ]
                        ]
                    }
                }
            );

        } catch (error) {
            console.error('Delete recipe error:', error);
            await ctx.reply('üêõ Error preparing deletion!');
        }
    });

    bot.action(/confirm_delete_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üóëÔ∏è Deleting recipe...');

            const { deleteRecipe } = require('../database/recipeService');
            const deleted = await deleteRecipe(recipeId, ctx.dbUser.id);

            if (deleted) {
                await safeEditMessage(ctx,
                    `‚úÖ **Recipe Deleted Successfully** ‚úÖ

üóëÔ∏è The recipe has been removed from your grimoire
üìö Your collection has been updated

üåø *The digital scroll returns to the ether...* ‚ú®`,
                    { parse_mode: 'Markdown' }
                );
            } else {
                await safeEditMessage(ctx,
                    '‚ùå **Deletion Failed** ‚ùå\n\nRecipe not found or not accessible.',
                    { parse_mode: 'Markdown' }
                );
            }

        } catch (error) {
            console.error('Confirm delete error:', error);
            await ctx.reply('üêõ Error deleting recipe!');
        }
    });

    bot.action('cancel_delete', async (ctx) => {
        try {
            await ctx.answerCbQuery('‚ùå Deletion cancelled');
            await safeEditMessage(ctx,
                `üåø **Recipe Preserved** üåø

üìö Your recipe remains safely in the grimoire
‚ú® *Moss approves of your careful consideration!* ‚ú®`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            console.error('Cancel delete error:', error);
        }
    });

    bot.action('search_recipes', async (ctx) => {
        await ctx.answerCbQuery('üîç Search feature coming soon!');
        await ctx.reply('üîç **Recipe Search** üîç\n\nüöß This feature is being developed!\n\n*Coming in Phase 1.3!* üåø');
    });

    bot.action('view_stats', async (ctx) => {
        try {
            await ctx.answerCbQuery('üìä Loading stats...');
            const { getUserStats } = require('../database/userService');
            const stats = await getUserStats(ctx.dbUser.id);

            await ctx.reply(`üìä *Your GreenGrimoire Stats* üìä

üç≥ **Total Recipes:** ${stats.total_recipes}
üì± **Platforms Used:** ${stats.platforms_used}
üìÇ **Categories Used:** ${stats.categories_used}
üìÖ **Member Since:** ${new Date(ctx.dbUser.created_at).toLocaleDateString()}

üåø *Keep cooking and growing your collection!* ‚ú®`,
                { parse_mode: 'Markdown' });

        } catch (error) {
            console.error('View stats error:', error);
            await ctx.reply('üêõ Error loading stats!');
        }
    });
};

const setupRatingButtonHandlers = (bot) => {
    bot.action(/rate_recipe_(\d+)/, async (ctx) => {
        console.log(`üîç RATE_RECIPE HANDLER CALLED: Recipe ${ctx.match[1]}, User ${ctx.dbUser.id}`);

        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('‚≠ê Opening rating interface...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found or not accessible!');
                return;
            }

            const existingRating = await getRecipeRating(recipeId, ctx.dbUser.id);
            console.log(`üîç EXISTING RATING:`, existingRating);

            const ratingText = existingRating ?
                `üîÑ **Update Rating** üîÑ\n\nüìù **Recipe:** ${recipe.title}\n‚≠ê **Current Rating:** ${existingRating.rating}/5 stars\n${existingRating.notes ? `üí≠ **Notes:** "${existingRating.notes}"\n` : ''}\nüåø *Choose your new rating:*` :
                `‚≠ê **Rate This Recipe** ‚≠ê\n\nüìù **Recipe:** ${recipe.title}\nüìÖ **Created:** ${new Date(recipe.created_at).toLocaleDateString()}\n\nüåø *How would you rate this recipe?*`;

            await ctx.reply(ratingText, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (5)', callback_data: `set_rating_${recipeId}_5` },
                            { text: '‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ (4)', callback_data: `set_rating_${recipeId}_4` }
                        ],
                        [
                            { text: '‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ (3)', callback_data: `set_rating_${recipeId}_3` },
                            { text: '‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ (2)', callback_data: `set_rating_${recipeId}_2` }
                        ],
                        [
                            { text: '‚≠ê‚òÜ‚òÜ‚òÜ‚òÜ (1)', callback_data: `set_rating_${recipeId}_1` }
                        ],
                        [
                            { text: 'üìù Add Notes', callback_data: `rate_notes_${recipeId}` },
                            existingRating ? { text: 'üóëÔ∏è Remove Rating', callback_data: `remove_rating_${recipeId}` } : { text: '‚ùå Cancel', callback_data: 'cancel_rating' }
                        ]
                    ]
                }
            });

        } catch (error) {
            console.error('Rate recipe error:', error);
            await ctx.reply('üêõ Error opening rating interface!');
        }
    });

    bot.action(/set_rating_(\d+)_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            const rating = parseInt(ctx.match[2]);

            await ctx.answerCbQuery(`‚≠ê Rating set to ${rating} stars!`);

            const result = await rateRecipe(recipeId, ctx.dbUser.id, rating);

            if (result.success) {
                const stars = '‚≠ê'.repeat(rating);
                const ratingWord = ['', 'Poor', 'Fair', 'Good', 'Great', 'Excellent'][rating];

                await safeEditMessage(ctx, `‚úÖ **Rating Saved!** ‚úÖ

üìù **Recipe:** ${result.recipeTitle}
‚≠ê **Rating:** ${stars} (${rating}/5) - ${ratingWord}

üåø *Would you like to add notes about this recipe?*`, {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'üìù Add Notes', callback_data: `rate_notes_${recipeId}` },
                                { text: 'üîÑ Change Rating', callback_data: `rate_recipe_${recipeId}` }
                            ],
                            [
                                { text: '‚úÖ Done', callback_data: 'rating_complete' }
                            ]
                        ]
                    }
                });
            }

        } catch (error) {
            console.error('Set rating error:', error);
            await ctx.reply('üêõ Error saving rating! Please try again.');
        }
    });

    bot.action(/rate_notes_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üìù Please send your notes...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found!');
                return;
            }

            await ctx.reply(`üìù **Add Rating Notes** üìù

üìú **Recipe:** ${recipe.title}

üí≠ **Please send your notes about this recipe:**
‚Ä¢ What did you think?
‚Ä¢ Any modifications you made?
‚Ä¢ Tips for next time?
‚Ä¢ How did it turn out?

*Send your message and I'll save it with your rating!*

*Or send /cancel to skip notes.*`, {
                parse_mode: 'Markdown'
            });

            global.pendingRatingNotes = global.pendingRatingNotes || new Map();
            global.pendingRatingNotes.set(ctx.from.id, {
                recipeId: recipeId,
                recipeTitle: recipe.title,
                timestamp: Date.now()
            });

        } catch (error) {
            console.error('Rating notes error:', error);
            await ctx.reply('üêõ Error setting up notes interface!');
        }
    });

    bot.action(/^remove_rating_(\d+)$/, async (ctx) => {
        console.log(`üîç REMOVE_RATING HANDLER CALLED: Recipe ${ctx.match[1]}, User ${ctx.dbUser.id}`);

        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üóëÔ∏è Removing rating...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found!');
                return;
            }

            console.log(`üîç SHOWING CONFIRMATION for recipe ${recipeId}`);

            await safeEditMessage(ctx, `üóëÔ∏è **Confirm Rating Removal** üóëÔ∏è

üìù **Recipe:** ${recipe.title}

‚ö†Ô∏è Are you sure you want to remove your rating for this recipe?

üåø *This action cannot be undone.*`, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: '‚úÖ Yes, Remove Rating', callback_data: `confirm_remove_rating_${recipeId}` },
                            { text: '‚ùå No, Keep Rating', callback_data: `rate_recipe_${recipeId}` }
                        ]
                    ]
                }
            });

        } catch (error) {
            console.error('Remove rating error:', error);
            await ctx.reply('üêõ Error preparing rating removal!');
        }
    });

    bot.action(/^confirm_remove_rating_(\d+)$/, async (ctx) => {
        console.log(`üîç CONFIRM_REMOVE_RATING HANDLER CALLED: Recipe ${ctx.match[1]}, User ${ctx.dbUser.id}`);

        try {
            const recipeId = parseInt(ctx.match[1]);
            await ctx.answerCbQuery('üóëÔ∏è Removing rating...');

            console.log(`üóëÔ∏è ATTEMPTING DELETE: Recipe ${recipeId}, User ${ctx.dbUser.id}`);
            const beforeRating = await getRecipeRating(recipeId, ctx.dbUser.id);
            console.log(`üîç RATING BEFORE DELETE:`, beforeRating);

            const deleted = await deleteRecipeRating(recipeId, ctx.dbUser.id);
            console.log(`üóëÔ∏è DELETE FUNCTION RESULT: ${deleted}`);

            const afterRating = await getRecipeRating(recipeId, ctx.dbUser.id);
            console.log(`üîç RATING AFTER DELETE:`, afterRating);

            if (deleted) {
                await safeEditMessage(ctx, `‚úÖ **Rating Successfully Removed!** ‚úÖ

üóëÔ∏è The rating has been permanently deleted
üìù You can rate this recipe again anytime

üåø *Rating cleared successfully!* ‚ú®`, {
                    parse_mode: 'Markdown'
                });
            } else {
                await safeEditMessage(ctx, `‚ùå **Rating Removal Failed** ‚ùå

Could not remove the rating. It may have already been deleted.`, {
                    parse_mode: 'Markdown'
                });
            }

        } catch (error) {
            console.error('üêõ CONFIRM REMOVE ERROR:', error);
            await ctx.reply(`üêõ Error: ${error.message}`);
        }
    });

    bot.action('rating_complete', async (ctx) => {
        await ctx.answerCbQuery('‚úÖ Rating saved!');
        await safeEditMessage(ctx, `‚úÖ <b>Rating Process Complete</b> ‚úÖ

‚≠ê Your rating has been saved successfully!

üìä Use /rate to view all your ratings
üèÜ Use /my_recipes to see your collection

üåø <i>Thank you for rating your recipes!</i> ‚ú®`, {
            parse_mode: 'HTML'
        });
    });

    bot.action('cancel_rating', async (ctx) => {
        await ctx.answerCbQuery('‚ùå Rating cancelled');
        await safeEditMessage(ctx, `‚ùå <b>Rating Cancelled</b> ‚ùå

No rating was saved.

üìä Use /rate anytime to rate your recipes
üç≥ Keep cooking and building your collection!

üåø <i>Moss returns to the grimoire...</i> ‚ú®`, {
            parse_mode: 'HTML'
        });
    });
};

const setupStatsHandlers = (bot) => {
    bot.action('open_rate_command', async (ctx) => {
        await ctx.answerCbQuery('‚≠ê Opening rating center...');
        const { rateCommand } = require('../commands/rate');
        await rateCommand(ctx);
    });

    bot.action('open_my_recipes', async (ctx) => {
        await ctx.answerCbQuery('üìö Opening recipe collection...');
        const myRecipesCommand = require('../commands/myRecipes');
        await myRecipesCommand(ctx);
    });
};

module.exports = {
    setupDownloadHandlers,
    setupRecipeHandlers,
    setupRatingButtonHandlers,
    setupStatsHandlers
};