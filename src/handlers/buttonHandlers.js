const { pendingDownloads } = require('../services/videoDownload');
const { rateRecipe, getRecipeRating, deleteRecipeRating } = require('../database/ratingService');
const { getRecipeById, updateRecipeNutrition  } = require('../database/recipeService');
const { query } = require('../database/connection');
const { analyzeRecipeNutrition } = require('../services/nutritionAnalyzer');

const safeEditMessage = async (ctx, text, options = {}) => {
    try {
        await ctx.editMessageText(text, options);
    } catch (error) {
        if (error.message.includes('message is not modified')) {
            console.log('Message already shows expected content - skipping edit');
            return;
        } else if (error.message.includes('message to edit not found')) {
            await ctx.reply(text, options);
        } else {
            throw error;
        }
    }
};

const setupDownloadHandlers = (bot) => {
    bot.action('download_confirm', async (ctx) => {
        try {
            await ctx.answerCbQuery('üîÆ Starting download ritual!');

            const userId = ctx.from.id;
            const pending = pendingDownloads.get(userId);

            if (!pending) {
                await safeEditMessage(ctx,
                    '‚ö†Ô∏è *Download session expired!* Please send the video link again.',
                    { parse_mode: 'Markdown' }
                );
                return;
            }

            pendingDownloads.delete(userId);

            await safeEditMessage(ctx,
                `üîÆ‚ö° *Moss prepares the downloading ritual!* ‚ö°üîÆ

üßô‚Äç‚ôÄÔ∏è *Your wish is my command, dear cook!*
üìú *Beginning the sacred video capture...*

*Ancient magic is flowing...* üåø‚ö°`,
                { parse_mode: 'Markdown' }
            );

            const { downloadActualVideo } = require('../services/videoDownload');
            await downloadActualVideo(pending.url, ctx, pending.videoInfo, ctx.callbackQuery.message.message_id);

        } catch (error) {
            console.error('Download confirm error:', error);
            await ctx.reply('üêõ Error starting download! Please try again.');
        }
    });

    bot.action('download_cancel', async (ctx) => {
        try {
            await ctx.answerCbQuery('‚ùå Download cancelled');

            const userId = ctx.from.id;
            pendingDownloads.delete(userId);

            await safeEditMessage(ctx,
                `üåø‚ú® *Moss nods understandingly* ‚ú®üåø

üßô‚Äç‚ôÄÔ∏è *No worries, dear cook! The video portal remains open in the ether.*
üìú *Send another video link anytime you're ready for downloading magic!*

*Moss returns to tending the grimoire...* üçÑüìö`,
                { parse_mode: 'Markdown' }
            );

        } catch (error) {
            console.error('Download cancel error:', error);
        }
    });

    bot.action('info_only', async (ctx) => {
        try {
            await ctx.answerCbQuery('üìã Video info preserved!');

            const userId = ctx.from.id;
            const pending = pendingDownloads.get(userId);
            pendingDownloads.delete(userId);

            await safeEditMessage(ctx,
                `üìã‚ö° *Video Information Preserved* ‚ö°üìã

üé¨ **Title:** ${pending?.videoInfo?.title || 'Unknown'}
‚è±Ô∏è **Duration:** ${pending?.videoInfo?.duration ? `${Math.floor(pending.videoInfo.duration / 60)}m ${Math.floor(pending.videoInfo.duration % 60)}s` : 'Unknown'}
üì± **Platform:** ${pending?.url?.includes('tiktok') ? 'TikTok' : pending?.url?.includes('youtube') ? 'YouTube' : 'Unknown'}

üåø *Video link saved for your reference - no download performed.*
üìú *Send another video link when ready for recipe extraction!*`,
                { parse_mode: 'Markdown' }
            );

        } catch (error) {
            console.error('Info only error:', error);
        }
    });
};

const setupRecipeHandlers = (bot) => {
    bot.action(/view_recipe_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üìñ Loading recipe...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);

            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found or not accessible!');
                return;
            }

            if (recipe.video_file_id && recipe.video_chat_id) {
                try {
                    await ctx.replyWithVideo(recipe.video_file_id, {
                        caption: `üé¨ **Original Video** üé¨\nüìù **Recipe:** ${recipe.title}\nüåø *Refreshing your memory with the source video!* ‚ú®`,
                        parse_mode: 'Markdown'
                    });
                } catch (videoError) {
                    console.log('Could not resend video (might be expired):', videoError.message);
                    if (recipe.original_video_url) {
                        await ctx.reply(`üîó **Original Video:** ${recipe.original_video_url}`);
                    }
                }
            }

            let message = `üìñ **${recipe.title}** üìñ

${recipe.structured_recipe}`;

            if (recipe.user_rating) {
                const stars = '‚≠ê'.repeat(recipe.user_rating);
                message += `\n\n‚≠ê **Your Rating:** ${stars} (${recipe.user_rating}/5)`;
                if (recipe.rating_notes) {
                    message += `\nüí≠ **Notes:** "${recipe.rating_notes}"`;
                }
            }

            message += `\n\nüìÖ **Saved:** ${new Date(recipe.created_at).toLocaleDateString()}
üì± **Platform:** ${recipe.video_platform}

üåø *From your digital grimoire* ‚ú®`;

            await ctx.reply(message, { parse_mode: 'Markdown' });

        } catch (error) {
            console.error('View recipe error:', error);
            await ctx.reply('üêõ Error loading recipe!');
        }
    });

    bot.action(/delete_recipe_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üóëÔ∏è Confirm deletion...');

            await ctx.reply(
                `üóëÔ∏è **Confirm Recipe Deletion** üóëÔ∏è

‚ö†Ô∏è Are you sure you want to delete this recipe?
üìö This action cannot be undone!

üåø *Choose wisely, dear cook...* ‚ú®`,
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: '‚úÖ Yes, Delete It', callback_data: `confirm_delete_${recipeId}` },
                                { text: '‚ùå No, Keep It', callback_data: 'cancel_delete' }
                            ]
                        ]
                    }
                }
            );

        } catch (error) {
            console.error('Delete recipe error:', error);
            await ctx.reply('üêõ Error preparing deletion!');
        }
    });

    bot.action(/confirm_delete_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üóëÔ∏è Deleting recipe...');

            const { deleteRecipe } = require('../database/recipeService');
            const deleted = await deleteRecipe(recipeId, ctx.dbUser.id);

            if (deleted) {
                await safeEditMessage(ctx,
                    `‚úÖ **Recipe Deleted Successfully** ‚úÖ

üóëÔ∏è The recipe has been removed from your grimoire
üìö Your collection has been updated

üåø *The digital scroll returns to the ether...* ‚ú®`,
                    { parse_mode: 'Markdown' }
                );
            } else {
                await safeEditMessage(ctx,
                    '‚ùå **Deletion Failed** ‚ùå\n\nRecipe not found or not accessible.',
                    { parse_mode: 'Markdown' }
                );
            }

        } catch (error) {
            console.error('Confirm delete error:', error);
            await ctx.reply('üêõ Error deleting recipe!');
        }
    });

    bot.action('cancel_delete', async (ctx) => {
        try {
            await ctx.answerCbQuery('‚ùå Deletion cancelled');
            await safeEditMessage(ctx,
                `üåø **Recipe Preserved** üåø

üìö Your recipe remains safely in the grimoire
‚ú® *Moss approves of your careful consideration!* ‚ú®`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            console.error('Cancel delete error:', error);
        }
    });

    bot.action('search_recipes', async (ctx) => {
        await ctx.answerCbQuery('üîç Search feature coming soon!');
        await ctx.reply('üîç **Recipe Search** üîç\n\nüöß This feature is being developed!\n\n*Coming in Phase 1.3!* üåø');
    });

    bot.action('view_stats', async (ctx) => {
        try {
            await ctx.answerCbQuery('üìä Loading stats...');
            const { getUserStats } = require('../database/userService');
            const stats = await getUserStats(ctx.dbUser.id);

            await ctx.reply(`üìä *Your GreenGrimoire Stats* üìä

üç≥ **Total Recipes:** ${stats.total_recipes}
üì± **Platforms Used:** ${stats.platforms_used}
üìÇ **Categories Used:** ${stats.categories_used}
üìÖ **Member Since:** ${new Date(ctx.dbUser.created_at).toLocaleDateString()}

üåø *Keep cooking and growing your collection!* ‚ú®`,
                { parse_mode: 'Markdown' });

        } catch (error) {
            console.error('View stats error:', error);
            await ctx.reply('üêõ Error loading stats!');
        }
    });

    bot.action(/^scale_recipe_(\d+)$/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('‚öñÔ∏è Opening scaling options...');
            const { setupScaleButtonHandlers } = require('./scaleHandlers');

            const mockContext = {
                ...ctx,
                match: [null, recipeId] // Simulate the match result
            };

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found or not accessible!');
                return;
            }

            const originalServings = recipe.servings || 'Unknown';
            const message = `‚öñÔ∏è **Recipe Scaling Options** ‚öñÔ∏è

üìù **Recipe:** ${recipe.title}
üçΩÔ∏è **Current Servings:** ${originalServings}
üìÖ **Created:** ${new Date(recipe.created_at).toLocaleDateString()}

üéØ **Choose your scaling factor:**

‚Ä¢ **0.5x** - Half portions (great for testing)
‚Ä¢ **1x** - Original recipe (no scaling)
‚Ä¢ **2x** - Double portions (family meal)
‚Ä¢ **4x** - Quadruple portions (meal prep/party)
‚Ä¢ **Custom** - Enter any specific number

üåø *Smart scaling adjusts ingredients, timing, and equipment!* ‚ú®`;

            await ctx.reply(message, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: '0.5x Half', callback_data: `scale_factor_${recipeId}_0.5` },
                            { text: '1x Original', callback_data: `scale_factor_${recipeId}_1` }
                        ],
                        [
                            { text: '2x Double', callback_data: `scale_factor_${recipeId}_2` },
                            { text: '4x Quadruple', callback_data: `scale_factor_${recipeId}_4` }
                        ],
                        [
                            { text: 'üî¢ Custom Scale', callback_data: `scale_custom_${recipeId}` }
                        ],
                        [
                            { text: 'üìñ Preview Recipe', callback_data: `view_recipe_${recipeId}` },
                            { text: '‚¨ÖÔ∏è Back', callback_data: 'back_to_recipe' }
                        ]
                    ]
                }
            });

        } catch (error) {
            console.error('Scale button handler error:', error);
            await ctx.reply('üêõ Error opening scaling options!');
        }
    });

    bot.action(/^analyze_nutrition_(\d+)$/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üî¨ Analyzing nutrition...');
            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found or not accessible!');
                return;
            }

            const processingMsg = await ctx.reply(`üî¨ **Analyzing Nutrition** üî¨

üìä Calculating calories and macronutrients for "${recipe.title}"...
üçé Analyzing dietary compatibility...

*This will take a moment...* ‚ö°`,
                { parse_mode: 'Markdown' });

            const nutritionResult = await analyzeRecipeNutrition(recipe.structured_recipe, recipe.title);

            if (nutritionResult.success) {
                const updatedRecipeContent = recipe.structured_recipe + nutritionResult.nutritionText;
                try {
                    await updateRecipeNutrition(recipeId, ctx.dbUser.id, updatedRecipeContent);
                } catch (updateError) {
                    console.log('Could not update recipe in database:', updateError.message);
                }

                try {
                    await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
                } catch (error) {}

                await ctx.reply(`‚úÖ Nutrition Analysis Complete! ‚úÖ

üìù **Recipe:** ${recipe.title}

${nutritionResult.nutritionText}

üíæ *Nutrition information has been saved to your recipe!*

üåø *Use this data to make informed health choices!* ‚ú®`,
                    { parse_mode: 'Markdown' });

                const updatedButtons = getUpdatedRecipeKeyboard(recipeId, true);
                await ctx.reply(`üç≥ Updated Recipe Actions:`, {
                    reply_markup: updatedButtons
                });

            } else {
                try {
                    await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
                } catch (error) {}
                await ctx.reply(`‚ùå Nutrition Analysis Failed ‚ùå

üêõ **Issue:** ${nutritionResult.error}

üîß **Possible causes:**
‚Ä¢ Ingredients not in nutrition database
‚Ä¢ Unclear ingredient quantities  
‚Ä¢ Complex ingredient preparations

üí° **What you can try:**
‚Ä¢ Check if ingredients have clear measurements
‚Ä¢ Some recipes work better than others
‚Ä¢ Complex dishes may need manual analysis

üåø *Don't worry - your recipe is still saved!* ‚ú®`,
                    { parse_mode: 'Markdown' });
            }

        } catch (error) {
            console.error('Nutrition analysis button error:', error);
            await ctx.reply('üêõ Error during nutrition analysis! Please try again.');
        }
    });

    bot.action('nutrition_help', async (ctx) => {
        await ctx.answerCbQuery('üí° Loading nutrition help...');

        const helpMessage = `üìä **About Nutrition Analysis** üìä

üî¨ **What it analyzes:**
‚Ä¢ üî• **Calories** per serving and total recipe
‚Ä¢ üí™ **Macronutrients** (protein, carbs, fat)
‚Ä¢ ü•ó **Fiber and sugar** content
‚Ä¢ üè∑Ô∏è **Dietary tags** (vegan, gluten-free, etc.)
‚Ä¢ üí° **Health insights** and recommendations

üìã **How it works:**
‚Ä¢ Analyzes ingredients from your recipe
‚Ä¢ Uses nutrition database of 50+ common foods
‚Ä¢ Calculates based on ingredient quantities
‚Ä¢ Provides estimates for healthy meal planning

‚öñÔ∏è **Accuracy notes:**
‚Ä¢ Values are estimates based on standard data
‚Ä¢ Actual nutrition may vary by preparation
‚Ä¢ Best for general dietary guidance
‚Ä¢ Professional nutrition advice recommended for medical needs

üçé **Perfect for:**
‚Ä¢ Calorie counting and weight management
‚Ä¢ Macro tracking for fitness goals
‚Ä¢ Identifying dietary restriction compatibility
‚Ä¢ Making informed healthy choices

üåø *Click "Analyze Nutrition" on any recipe to get detailed health information!* ‚ú®`;

        await ctx.reply(helpMessage, {
            parse_mode: 'Markdown',
            reply_markup: {
                inline_keyboard: [
                    [{ text: '‚¨ÖÔ∏è Back', callback_data: 'nutrition_help_back' }]
                ]
            }
        });
    });

    bot.action('nutrition_help_back', async (ctx) => {
        await ctx.answerCbQuery('‚¨ÖÔ∏è Going back...');
        await ctx.deleteMessage();
    });
};

const getRecipeKeyboard = (recipeId, hasNutritionAnalysis = false) => {
    const baseButtons = [
        [
            { text: '‚≠ê Rate', callback_data: `rate_recipe_${recipeId}` },
            { text: '‚öñÔ∏è Scale', callback_data: `scale_recipe_${recipeId}` }
        ]
    ];

    if (!hasNutritionAnalysis) {
        baseButtons.push([
            { text: 'üìä Analyze Nutrition', callback_data: `analyze_nutrition_${recipeId}` },
            { text: 'üí° Nutrition Help', callback_data: 'nutrition_help' }
        ]);
    } else {
        baseButtons.push([
            { text: '‚úÖ Nutrition Analyzed', callback_data: 'nutrition_already_done' },
            { text: 'üîÑ Re-analyze', callback_data: `analyze_nutrition_${recipeId}` }
        ]);
    }

    return {
        inline_keyboard: baseButtons
    };
};

const getUpdatedRecipeKeyboard = (recipeId, hasNutrition = true) => {
    return {
        inline_keyboard: [
            [
                { text: '‚≠ê Rate', callback_data: `rate_recipe_${recipeId}` },
                { text: '‚öñÔ∏è Scale', callback_data: `scale_recipe_${recipeId}` }
            ],
            [
                { text: '‚úÖ Nutrition Complete', callback_data: 'nutrition_already_done' },
                { text: 'üîÑ Re-analyze', callback_data: `analyze_nutrition_${recipeId}` }
            ],
            [
                { text: 'üìñ View Recipe', callback_data: `view_recipe_${recipeId}` }
            ]
        ]
    };
};

const setupNutritionStatusHandlers = (bot) => {
    bot.action('nutrition_already_done', async (ctx) => {
        await ctx.answerCbQuery('‚úÖ This recipe already has nutrition analysis!');

        await ctx.reply(`‚úÖ **Nutrition Already Analyzed** ‚úÖ

üìä This recipe already includes detailed nutrition information!

üîç **To view the nutrition data:**
‚Ä¢ Scroll up to see the complete recipe with nutrition
‚Ä¢ Look for the "üìä NUTRITION ANALYSIS" section

üîÑ **To update the analysis:**
‚Ä¢ Click "Re-analyze" if you've modified ingredients
‚Ä¢ Useful if the original analysis had errors

üåø *Your health data is ready to use!* ‚ú®`,
            { parse_mode: 'Markdown' });
    });
};

const setupRatingButtonHandlers = (bot) => {
    bot.action(/rate_recipe_(\d+)/, async (ctx) => {
        console.log(`üîç RATE_RECIPE HANDLER CALLED: Recipe ${ctx.match[1]}, User ${ctx.dbUser.id}`);

        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('‚≠ê Opening rating interface...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found or not accessible!');
                return;
            }

            const existingRating = await getRecipeRating(recipeId, ctx.dbUser.id);
            console.log(`üîç EXISTING RATING:`, existingRating);

            const ratingText = existingRating ?
                `üîÑ **Update Rating** üîÑ\n\nüìù **Recipe:** ${recipe.title}\n‚≠ê **Current Rating:** ${existingRating.rating}/5 stars\n${existingRating.notes ? `üí≠ **Notes:** "${existingRating.notes}"\n` : ''}\nüåø *Choose your new rating:*` :
                `‚≠ê **Rate This Recipe** ‚≠ê\n\nüìù **Recipe:** ${recipe.title}\nüìÖ **Created:** ${new Date(recipe.created_at).toLocaleDateString()}\n\nüåø *How would you rate this recipe?*`;

            await ctx.reply(ratingText, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (5)', callback_data: `set_rating_${recipeId}_5` },
                            { text: '‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ (4)', callback_data: `set_rating_${recipeId}_4` }
                        ],
                        [
                            { text: '‚≠ê‚≠ê‚≠ê‚òÜ‚òÜ (3)', callback_data: `set_rating_${recipeId}_3` },
                            { text: '‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ (2)', callback_data: `set_rating_${recipeId}_2` }
                        ],
                        [
                            { text: '‚≠ê‚òÜ‚òÜ‚òÜ‚òÜ (1)', callback_data: `set_rating_${recipeId}_1` }
                        ],
                        [
                            { text: 'üìù Add Notes', callback_data: `rate_notes_${recipeId}` },
                            existingRating ? { text: 'üóëÔ∏è Remove Rating', callback_data: `remove_rating_${recipeId}` } : { text: '‚ùå Cancel', callback_data: 'cancel_rating' }
                        ]
                    ]
                }
            });

        } catch (error) {
            console.error('Rate recipe error:', error);
            await ctx.reply('üêõ Error opening rating interface!');
        }
    });

    bot.action(/set_rating_(\d+)_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            const rating = parseInt(ctx.match[2]);

            await ctx.answerCbQuery(`‚≠ê Rating set to ${rating} stars!`);

            const result = await rateRecipe(recipeId, ctx.dbUser.id, rating);

            if (result.success) {
                const stars = '‚≠ê'.repeat(rating);
                const ratingWord = ['', 'Poor', 'Fair', 'Good', 'Great', 'Excellent'][rating];

                await safeEditMessage(ctx, `‚úÖ **Rating Saved!** ‚úÖ

üìù **Recipe:** ${result.recipeTitle}
‚≠ê **Rating:** ${stars} (${rating}/5) - ${ratingWord}

üåø *Would you like to add notes about this recipe?*`, {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'üìù Add Notes', callback_data: `rate_notes_${recipeId}` },
                                { text: 'üîÑ Change Rating', callback_data: `rate_recipe_${recipeId}` }
                            ],
                            [
                                { text: '‚úÖ Done', callback_data: 'rating_complete' }
                            ]
                        ]
                    }
                });
            }

        } catch (error) {
            console.error('Set rating error:', error);
            await ctx.reply('üêõ Error saving rating! Please try again.');
        }
    });

    bot.action(/rate_notes_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üìù Please send your notes...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found!');
                return;
            }

            await ctx.reply(`üìù **Add Rating Notes** üìù

üìú **Recipe:** ${recipe.title}

üí≠ **Please send your notes about this recipe:**
‚Ä¢ What did you think?
‚Ä¢ Any modifications you made?
‚Ä¢ Tips for next time?
‚Ä¢ How did it turn out?

*Send your message and I'll save it with your rating!*

*Or send /cancel to skip notes.*`, {
                parse_mode: 'Markdown'
            });

            global.pendingRatingNotes = global.pendingRatingNotes || new Map();
            global.pendingRatingNotes.set(ctx.from.id, {
                recipeId: recipeId,
                recipeTitle: recipe.title,
                timestamp: Date.now()
            });

        } catch (error) {
            console.error('Rating notes error:', error);
            await ctx.reply('üêõ Error setting up notes interface!');
        }
    });

    bot.action(/^remove_rating_(\d+)$/, async (ctx) => {
        console.log(`üîç REMOVE_RATING HANDLER CALLED: Recipe ${ctx.match[1]}, User ${ctx.dbUser.id}`);

        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üóëÔ∏è Removing rating...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found!');
                return;
            }

            console.log(`üîç SHOWING CONFIRMATION for recipe ${recipeId}`);

            await safeEditMessage(ctx, `üóëÔ∏è **Confirm Rating Removal** üóëÔ∏è

üìù **Recipe:** ${recipe.title}

‚ö†Ô∏è Are you sure you want to remove your rating for this recipe?

üåø *This action cannot be undone.*`, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: '‚úÖ Yes, Remove Rating', callback_data: `confirm_remove_rating_${recipeId}` },
                            { text: '‚ùå No, Keep Rating', callback_data: `rate_recipe_${recipeId}` }
                        ]
                    ]
                }
            });

        } catch (error) {
            console.error('Remove rating error:', error);
            await ctx.reply('üêõ Error preparing rating removal!');
        }
    });

    bot.action(/^confirm_remove_rating_(\d+)$/, async (ctx) => {
        console.log(`üîç CONFIRM_REMOVE_RATING HANDLER CALLED: Recipe ${ctx.match[1]}, User ${ctx.dbUser.id}`);

        try {
            const recipeId = parseInt(ctx.match[1]);
            await ctx.answerCbQuery('üóëÔ∏è Removing rating...');

            console.log(`üóëÔ∏è ATTEMPTING DELETE: Recipe ${recipeId}, User ${ctx.dbUser.id}`);
            const beforeRating = await getRecipeRating(recipeId, ctx.dbUser.id);
            console.log(`üîç RATING BEFORE DELETE:`, beforeRating);

            const deleted = await deleteRecipeRating(recipeId, ctx.dbUser.id);
            console.log(`üóëÔ∏è DELETE FUNCTION RESULT: ${deleted}`);

            const afterRating = await getRecipeRating(recipeId, ctx.dbUser.id);
            console.log(`üîç RATING AFTER DELETE:`, afterRating);

            if (deleted) {
                await safeEditMessage(ctx, `‚úÖ **Rating Successfully Removed!** ‚úÖ

üóëÔ∏è The rating has been permanently deleted
üìù You can rate this recipe again anytime

üåø *Rating cleared successfully!* ‚ú®`, {
                    parse_mode: 'Markdown'
                });
            } else {
                await safeEditMessage(ctx, `‚ùå **Rating Removal Failed** ‚ùå

Could not remove the rating. It may have already been deleted.`, {
                    parse_mode: 'Markdown'
                });
            }

        } catch (error) {
            console.error('üêõ CONFIRM REMOVE ERROR:', error);
            await ctx.reply(`üêõ Error: ${error.message}`);
        }
    });

    bot.action('rating_complete', async (ctx) => {
        await ctx.answerCbQuery('‚úÖ Rating saved!');
        await safeEditMessage(ctx, `‚úÖ <b>Rating Process Complete</b> ‚úÖ

‚≠ê Your rating has been saved successfully!

üìä Use /rate to view all your ratings
üèÜ Use /my_recipes to see your collection

üåø <i>Thank you for rating your recipes!</i> ‚ú®`, {
            parse_mode: 'HTML'
        });
    });

    bot.action('cancel_rating', async (ctx) => {
        await ctx.answerCbQuery('‚ùå Rating cancelled');
        await safeEditMessage(ctx, `‚ùå <b>Rating Cancelled</b> ‚ùå

No rating was saved.

üìä Use /rate anytime to rate your recipes
üç≥ Keep cooking and building your collection!

üåø <i>Moss returns to the grimoire...</i> ‚ú®`, {
            parse_mode: 'HTML'
        });
    });
};

const setupStatsHandlers = (bot) => {
    bot.action('open_rate_command', async (ctx) => {
        await ctx.answerCbQuery('‚≠ê Opening rating center...');
        const { rateCommand } = require('../commands/rate');
        await rateCommand(ctx);
    });

    bot.action('open_my_recipes', async (ctx) => {
        await ctx.answerCbQuery('üìö Opening recipe collection...');
        const myRecipesCommand = require('../commands/myRecipes');
        await myRecipesCommand(ctx);
    });
};

const setupNutritionHandlers = (bot) => {
    bot.action(/^analyze_nutrition_(\d+)$/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];

            await ctx.answerCbQuery('üî¨ Analyzing nutrition...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found or not accessible!');
                return;
            }

            const processingMsg = await ctx.reply(`üî¨ **Analyzing Nutrition** üî¨

üìä Calculating calories and macronutrients for "${recipe.title}"...
üçé Analyzing dietary compatibility...

*This will take a moment...* ‚ö°`,
                { parse_mode: 'Markdown' });

            const nutritionResult = await analyzeRecipeNutrition(recipe.structured_recipe, recipe.title);

            if (nutritionResult.success) {
                const updatedRecipeContent = recipe.structured_recipe + nutritionResult.nutritionText;
                try {
                    await updateRecipeNutrition(recipeId, ctx.dbUser.id, updatedRecipeContent);
                } catch (updateError) {
                    console.log('Could not update recipe in database:', updateError.message);
                }

                try {
                    await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
                } catch (error) {}

                await ctx.reply(`‚úÖ **Nutrition Analysis Complete!** ‚úÖ

üìù **Recipe:** ${recipe.title}

${nutritionResult.nutritionText}

üíæ *Nutrition information has been saved to your recipe!*

üåø *Use this data to make informed health choices!* ‚ú®`,
                    { parse_mode: 'Markdown' });

                setTimeout(async () => {
                    try {
                        await ctx.reply(`üîÑ **Recipe Updated!** 

üìä Nutrition analysis has been added to "${recipe.title}"
‚úÖ Future views will include the nutrition data
üîç Use /my_recipes to see your updated collection

*Recipe now includes complete health information!* üåø‚ú®`,
                            { parse_mode: 'Markdown' });
                    } catch (error) {}
                }, 1000);

            } else {
                try {
                    await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
                } catch (error) {}
                await ctx.reply(`‚ùå **Nutrition Analysis Failed** ‚ùå

üêõ **Issue:** ${nutritionResult.error}

üîß **Possible causes:**
‚Ä¢ Ingredients not in nutrition database
‚Ä¢ Unclear ingredient quantities  
‚Ä¢ Complex ingredient preparations

üí° **What you can try:**
‚Ä¢ Check if ingredients have clear measurements
‚Ä¢ Some recipes work better than others
‚Ä¢ Complex dishes may need manual analysis

üåø *Don't worry - your recipe is still saved!* ‚ú®`,
                    { parse_mode: 'Markdown' });
            }
        } catch (error) {
            console.error('Nutrition analysis button error:', error);
            await ctx.reply('üêõ Error during nutrition analysis! Please try again.');
        }
    });

    bot.action('nutrition_help', async (ctx) => {
        await ctx.answerCbQuery('üí° Loading nutrition help...');

        const helpMessage = `üìä **About Nutrition Analysis** üìä

üî¨ **What it analyzes:**
‚Ä¢ üî• **Calories** per serving and total recipe
‚Ä¢ üí™ **Macronutrients** (protein, carbs, fat)
‚Ä¢ ü•ó **Fiber and sugar** content
‚Ä¢ üè∑Ô∏è **Dietary tags** (vegan, gluten-free, etc.)
‚Ä¢ üí° **Health insights** and recommendations

üìã **How it works:**
‚Ä¢ Analyzes ingredients from your recipe
‚Ä¢ Uses nutrition database of 50+ common foods
‚Ä¢ Calculates based on ingredient quantities
‚Ä¢ Provides estimates for healthy meal planning

‚öñÔ∏è **Accuracy notes:**
‚Ä¢ Values are estimates based on standard data
‚Ä¢ Actual nutrition may vary by preparation
‚Ä¢ Best for general dietary guidance

üçé **Perfect for:**
‚Ä¢ Calorie counting and weight management
‚Ä¢ Macro tracking for fitness goals
‚Ä¢ Identifying dietary restriction compatibility
‚Ä¢ Making informed healthy choices

üåø *Click "Analyze Nutrition" on any recipe to get detailed health information!* ‚ú®`;

        await ctx.reply(helpMessage, { parse_mode: 'Markdown' });
    });

    bot.action('nutrition_already_done', async (ctx) => {
        await ctx.answerCbQuery('‚úÖ This recipe already has nutrition analysis!');

        await ctx.reply(`‚úÖ **Nutrition Already Analyzed** ‚úÖ

üìä This recipe already includes detailed nutrition information!

üîç **To view the nutrition data:**
‚Ä¢ Use /my_recipes to see your collection
‚Ä¢ Look for recipes with nutrition sections
‚Ä¢ Full nutrition details are included in the recipe text

üîÑ **To update the analysis:**
‚Ä¢ Click "Re-analyze" if you've modified ingredients
‚Ä¢ Useful if the original analysis had errors

üåø *Your health data is ready to use!* ‚ú®`,
            { parse_mode: 'Markdown' });
    });
};

module.exports = {
    setupDownloadHandlers,
    setupRecipeHandlers,
    setupRatingButtonHandlers,
    setupStatsHandlers,
    setupNutritionHandlers,
    setupNutritionStatusHandlers,
    getRecipeKeyboard,
    getUpdatedRecipeKeyboard
};