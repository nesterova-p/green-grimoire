const { getRecipeById } = require('../database/recipeService');
const { scaleRecipe } = require('../services/recipeScaler');

const setupScaleButtonHandlers = (bot) => {
    bot.action(/scale_recipe_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('‚öñÔ∏è Loading recipe for scaling...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found or not accessible!');
                return;
            }

            const originalServings = recipe.servings || 'Unknown';
            const message = `‚öñÔ∏è **Recipe Scaling Options** ‚öñÔ∏è

üìù **Recipe:** ${recipe.title}
üçΩÔ∏è **Current Servings:** ${originalServings}
üìÖ **Created:** ${new Date(recipe.created_at).toLocaleDateString()}

üéØ **Choose your scaling factor:**

‚Ä¢ **0.5x** - Half portions (great for testing)
‚Ä¢ **1x** - Original recipe (no scaling)
‚Ä¢ **2x** - Double portions (family meal)
‚Ä¢ **4x** - Quadruple portions (meal prep/party)
‚Ä¢ **Custom** - Enter any specific number

üåø *Smart scaling adjusts ingredients, timing, and equipment!* ‚ú®`;

            await ctx.reply(message, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [
                            { text: '0.5x Half', callback_data: `scale_factor_${recipeId}_0.5` },
                            { text: '1x Original', callback_data: `scale_factor_${recipeId}_1` }
                        ],
                        [
                            { text: '2x Double', callback_data: `scale_factor_${recipeId}_2` },
                            { text: '4x Quadruple', callback_data: `scale_factor_${recipeId}_4` }
                        ],
                        [
                            { text: 'üî¢ Custom Scale', callback_data: `scale_custom_${recipeId}` }
                        ],
                        [
                            { text: 'üìñ Preview Recipe', callback_data: `view_recipe_${recipeId}` },
                            { text: '‚¨ÖÔ∏è Back to Scale Menu', callback_data: 'back_to_scale_menu' }
                        ]
                    ]
                }
            });

        } catch (error) {
            console.error('Scale recipe selection error:', error);
            await ctx.reply('üêõ Error loading recipe for scaling!');
        }
    });

    bot.action(/scale_factor_(\d+)_([\d\.]+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            const scaleFactor = parseFloat(ctx.match[2]);

            await ctx.answerCbQuery(`‚öñÔ∏è Scaling recipe by ${scaleFactor}x...`);

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found!');
                return;
            }

            const processingMsg = await ctx.reply(`üîÑ **Scaling in Progress** üîÑ

‚öñÔ∏è **Recipe:** ${recipe.title}
üî¢ **Scale Factor:** ${scaleFactor}x
üßÆ **Processing:** Adjusting ingredients and timing...

*Smart scaling magic in progress...* üåø‚ú®`,
                { parse_mode: 'Markdown' });

            const scalingResult = await scaleRecipe(recipe, scaleFactor, ctx);

            if (scalingResult.success) {
                try {
                    await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
                } catch (e) {}

                await ctx.reply(`‚úÖ **Recipe Successfully Scaled!** ‚úÖ

${scalingResult.scaledRecipeText}`,
                    {
                        parse_mode: 'Markdown',
                        reply_markup: {
                            inline_keyboard: [
                                [
                                    { text: 'üìä Try Different Scale', callback_data: `scale_recipe_${recipeId}` },
                                    { text: 'üìñ View Original', callback_data: `view_recipe_${recipeId}` }
                                ],
                                [
                                    { text: 'üíæ Save Scaled Version', callback_data: `save_scaled_${recipeId}_${scaleFactor}` }
                                ],
                                [
                                    { text: '‚¨ÖÔ∏è Back to Scaling', callback_data: 'back_to_scale_menu' }
                                ]
                            ]
                        }
                    });

                setTimeout(async () => {
                    const summary = `üìä **Scaling Summary** üìä

üî¢ **Factor:** ${scaleFactor}x scaling applied
üçΩÔ∏è **Servings:** ${scalingResult.originalServings} ‚Üí ${scalingResult.newServings}
üìà **Changes:**
${scalingResult.scalingNotes.map(note => `‚Ä¢ ${note}`).join('\n')}

‚ö° **Pro Tips:**
‚Ä¢ Monitor cooking closely on first attempt
‚Ä¢ Taste and adjust seasonings after scaling
‚Ä¢ Check equipment size requirements

üåø *Perfect portions achieved!* ‚ú®`;

                    await ctx.reply(summary, { parse_mode: 'Markdown' });
                }, 1000);

            } else {
                await ctx.telegram.editMessageText(
                    ctx.chat.id,
                    processingMsg.message_id,
                    null,
                    `‚ùå **Scaling Failed** ‚ùå

üêõ **Error:** ${scalingResult.error || 'Unknown scaling error'}

üîß **Possible causes:**
- Complex recipe format not supported
- Missing ingredient quantity information
- Recipe text parsing issues

üìù **What you can do:**
- Try viewing the original recipe
- Manual scaling may be needed
- Contact support if this persists

üåø *Moss is learning to scale more recipe formats!* ‚ú®`,
                    { parse_mode: 'Markdown' }
                );
            }

        } catch (error) {
            console.error('Recipe scaling error:', error);
            await ctx.reply(`üêõ **Scaling Error** üêõ

${error.message || 'Unknown scaling error occurred'}

üîß Please try again or try a different scale factor.`);
        }
    });

    bot.action(/scale_custom_(\d+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            await ctx.answerCbQuery('üî¢ Please enter custom scale factor...');

            const recipe = await getRecipeById(recipeId, ctx.dbUser.id);
            if (!recipe) {
                await ctx.reply('‚ùå Recipe not found!');
                return;
            }

            await ctx.reply(`üî¢ **Custom Recipe Scaling** üî¢

üìù **Recipe:** ${recipe.title}
üçΩÔ∏è **Current Servings:** ${recipe.servings || 'Unknown'}

üéØ **Enter your custom scale factor:**

**Examples:**
‚Ä¢ **0.75** for 3/4 portions
‚Ä¢ **1.5** for 1.5x portions  
‚Ä¢ **3** for triple portions
‚Ä¢ **6** for 6x portions

üì§ **Send a number** (decimals allowed) and I'll scale the recipe!

*Or send /cancel to go back.*

üåø *Any scale factor between 0.1 and 10 works!* ‚ú®`,
                { parse_mode: 'Markdown' });

            if (!global.pendingCustomScaling) {
                global.pendingCustomScaling = new Map();
            }

            global.pendingCustomScaling.set(ctx.from.id, {
                recipeId: recipeId,
                recipeTitle: recipe.title,
                timestamp: Date.now()
            });

        } catch (error) {
            console.error('Custom scaling setup error:', error);
            await ctx.reply('üêõ Error setting up custom scaling!');
        }
    });

    bot.action(/save_scaled_(\d+)_([\d\.]+)/, async (ctx) => {
        try {
            const recipeId = ctx.match[1];
            const scaleFactor = parseFloat(ctx.match[2]);

            await ctx.answerCbQuery('üíæ Saving scaled recipe...');

            await ctx.reply(`üíæ **Save Scaled Recipe** üíæ

üîÑ **This feature is coming soon!**

üìù **What it will do:**
‚Ä¢ Save the scaled recipe as a new entry
‚Ä¢ Preserve both original and scaled versions
‚Ä¢ Add scaling notes and modifications
‚Ä¢ Allow custom naming for scaled recipes

üéØ **For now, you can:**
‚Ä¢ Screenshot the scaled recipe above
‚Ä¢ Copy the text for manual saving
‚Ä¢ Bookmark this chat message

üåø *Recipe saving enhancement coming in Phase 2!* ‚ú®`,
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'üìä Scale Again', callback_data: `scale_recipe_${recipeId}` },
                                { text: '‚¨ÖÔ∏è Back to Menu', callback_data: 'back_to_scale_menu' }
                            ]
                        ]
                    }
                });

        } catch (error) {
            console.error('Save scaled recipe error:', error);
            await ctx.reply('üêõ Error preparing to save scaled recipe!');
        }
    });

    bot.action('back_to_scale_menu', async (ctx) => {
        await ctx.answerCbQuery('‚öñÔ∏è Back to scaling center');
        await ctx.deleteMessage();
        const { scaleCommand } = require('../commands/scale');
        await scaleCommand(ctx);
    });
};

const handleCustomScalingInput = async (ctx, userMessage) => {
    if (!global.pendingCustomScaling) return false;

    const userId = ctx.from.id;
    const pendingScale = global.pendingCustomScaling.get(userId);

    if (!pendingScale) return false;

    if (Date.now() - pendingScale.timestamp > 5 * 60 * 1000) {
        global.pendingCustomScaling.delete(userId);
        await ctx.reply('‚è∞ Custom scaling session expired. Please use /scale to try again.');
        return true;
    }

    if (userMessage.toLowerCase().trim() === '/cancel') {
        global.pendingCustomScaling.delete(userId);
        await ctx.reply('‚ùå Custom scaling cancelled.');
        return true;
    }

    const scaleMatch = userMessage.match(/^(\d*\.?\d+)$/);
    if (!scaleMatch) {
        await ctx.reply(`üî¢ **Invalid Scale Factor** üî¢

‚ùå "${userMessage}" is not a valid number.

üìù **Please send:**
‚Ä¢ A number like **2** or **1.5** or **0.75**
‚Ä¢ Decimals are allowed
‚Ä¢ Range: 0.1 to 10

üåø *Try again or send /cancel to stop.* ‚ú®`);
        return true;
    }

    const scaleFactor = parseFloat(scaleMatch[1]);
    if (scaleFactor < 0.1 || scaleFactor > 10) {
        await ctx.reply(`‚ö†Ô∏è **Scale Factor Out of Range** ‚ö†Ô∏è

üî¢ **${scaleFactor}** is outside the supported range.

üìä **Supported range:** 0.1x to 10x
‚Ä¢ **Minimum:** 0.1 (1/10th portions)
‚Ä¢ **Maximum:** 10 (ten times larger)

üåø *Please enter a number between 0.1 and 10.* ‚ú®`);
        return true;
    }

    global.pendingCustomScaling.delete(userId);

    try {
        const recipe = await getRecipeById(pendingScale.recipeId, ctx.dbUser.id);
        if (!recipe) {
            await ctx.reply('‚ùå Recipe not found! Please try scaling again.');
            return true;
        }

        const processingMsg = await ctx.reply(`üîÑ **Custom Scaling in Progress** üîÑ

‚öñÔ∏è **Recipe:** ${pendingScale.recipeTitle}
üî¢ **Custom Factor:** ${scaleFactor}x
üßÆ **Processing:** Adjusting ingredients and timing...

*Custom scaling magic in progress...* üåø‚ú®`,
            { parse_mode: 'Markdown' });

        const scalingResult = await scaleRecipe(recipe, scaleFactor, ctx);

        if (scalingResult.success) {
            // rmv processing msg
            try {
                await ctx.telegram.deleteMessage(ctx.chat.id, processingMsg.message_id);
            } catch (e) {}

            // results
            await ctx.reply(`‚úÖ **Custom Scaling Complete!** ‚úÖ

${scalingResult.scaledRecipeText}`,
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'üìä Try Different Scale', callback_data: `scale_recipe_${pendingScale.recipeId}` },
                                { text: 'üìñ View Original', callback_data: `view_recipe_${pendingScale.recipeId}` }
                            ],
                            [
                                { text: '‚¨ÖÔ∏è Back to Scaling', callback_data: 'back_to_scale_menu' }
                            ]
                        ]
                    }
                });

        } else {
            await ctx.telegram.editMessageText(
                ctx.chat.id,
                processingMsg.message_id,
                null,
                `‚ùå **Custom Scaling Failed** ‚ùå

üêõ **Error:** ${scalingResult.error || 'Unknown scaling error'}

üîß The custom factor ${scaleFactor}x couldn't be applied.
üåø *Please try with a different scale factor.* ‚ú®`,
                { parse_mode: 'Markdown' }
            );
        }

    } catch (error) {
        console.error('Custom scaling error:', error);
        await ctx.reply(`üêõ **Custom Scaling Error** üêõ

${error.message || 'Unknown error during custom scaling'}

üîß Please try again with a different scale factor.`);
    }

    return true;
};

module.exports = {
    setupScaleButtonHandlers,
    handleCustomScalingInput
};